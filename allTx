BRBase58.c://  breadwallet-core
BRBase58.h://  breadwallet-core
BRBech32.c://  breadwallet-core
BRBech32.h://  breadwallet-core
BRWallet.c:        if (_BRWalletTxIsAscending(wallet, BRSetGet(wallet->allTx, &(tx1->inputs[i].txHash)), tx2)) return 1;
BRWallet.c:    i = _txChainIndex(tx1, wallet->internalChain);
BRWallet.c:    j = _txChainIndex(tx2, (i == SIZE_MAX) ? wallet->externalChain : wallet->internalChain);
BRWallet.c:    if (i == SIZE_MAX && j != SIZE_MAX) i = _txChainIndex((BRTransaction *)tx1, wallet->externalChain);
BRWallet.c:// inserts tx into wallet->transactions, keeping wallet->transactions sorted by date, oldest first (insertion sort)
BRWallet.c:    size_t i = array_count(wallet->transactions);
BRWallet.c:    array_set_count(wallet->transactions, i + 1);
BRWallet.c:    while (i > 0 && _BRWalletTxCompare(wallet, wallet->transactions[i - 1], tx) > 0) {
BRWallet.c:        wallet->transactions[i] = wallet->transactions[i - 1];
BRWallet.c:    wallet->transactions[i] = tx;
BRWallet.c:        if (BRSetContains(wallet->allAddrs, tx->outputs[i].address)) r = 1;
BRWallet.c:        BRTransaction *t = BRSetGet(wallet->allTx, &tx->inputs[i].txHash);
BRWallet.c:        if (t && n < t->outCount && BRSetContains(wallet->allAddrs, t->outputs[n].address)) r = 1;
BRWallet.c://        if (BRSetContains(wallet->allAddrs, tx->inputs[i].address)) r = 1;
BRWallet.c:    array_clear(wallet->utxos);
BRWallet.c:    array_clear(wallet->balanceHist);
BRWallet.c:    BRSetClear(wallet->spentOutputs);
BRWallet.c:    BRSetClear(wallet->invalidTx);
BRWallet.c:    BRSetClear(wallet->pendingTx);
BRWallet.c:    BRSetClear(wallet->usedAddrs);
BRWallet.c:    wallet->totalSent = 0;
BRWallet.c:    wallet->totalReceived = 0;
BRWallet.c:    size_t transactionCount = array_count(wallet->transactions);
BRWallet.c:        tx = wallet->transactions[i];
BRWallet.c:                if (BRSetContains(wallet->spentOutputs, &tx->inputs[j]) ||
BRWallet.c:                    BRSetContains(wallet->invalidTx, &tx->inputs[j].txHash)) isInvalid = 1;
BRWallet.c:                BRSetAdd(wallet->invalidTx, tx);
BRWallet.c:                array_add(wallet->balanceHist, balance);
BRWallet.c:            BRSetAdd(wallet->spentOutputs, &tx->inputs[j]);
BRWallet.c:                    tx->lockTime > wallet->blockHeight + 1) isPending = 1; // future lockTime
BRWallet.c:                if (BRSetContains(wallet->pendingTx, &tx->inputs[j].txHash)) isPending = 1; // check for pending inputs
BRWallet.c:                BRSetAdd(wallet->pendingTx, tx);
BRWallet.c:                array_add(wallet->balanceHist, balance);
BRWallet.c:                BRSetAdd(wallet->usedAddrs, tx->outputs[j].address);
BRWallet.c:                if (BRSetContains(wallet->allAddrs, tx->outputs[j].address)) {
BRWallet.c:                    array_add(wallet->utxos, ((BRUTXO) { tx->txHash, (uint32_t)j }));
BRWallet.c:        for (j = array_count(wallet->utxos); j > 0; j--) {
BRWallet.c:            if (! BRSetContains(wallet->spentOutputs, &wallet->utxos[j - 1])) continue;
BRWallet.c:            t = BRSetGet(wallet->allTx, &wallet->utxos[j - 1].hash);
BRWallet.c:            balance -= t->outputs[wallet->utxos[j - 1].n].amount;
BRWallet.c:            array_rm(wallet->utxos, j - 1);
BRWallet.c:        if (prevBalance < balance) wallet->totalReceived += balance - prevBalance;
BRWallet.c:        if (balance < prevBalance) wallet->totalSent += prevBalance - balance;
BRWallet.c:        array_add(wallet->balanceHist, balance);
BRWallet.c:    assert(array_count(wallet->balanceHist) == array_count(wallet->transactions));
BRWallet.c:    wallet->balance = balance;
BRWallet.c:    array_new(wallet->utxos, 100);
BRWallet.c:    array_new(wallet->transactions, txCount + 100);
BRWallet.c:    wallet->feePerKb = DEFAULT_FEE_PER_KB;
BRWallet.c:    wallet->masterPubKey = mpk;
BRWallet.c:    array_new(wallet->internalChain, 100);
BRWallet.c:    array_new(wallet->externalChain, 100);
BRWallet.c:    array_new(wallet->balanceHist, txCount + 100);
BRWallet.c:    wallet->allTx = BRSetNew(BRTransactionHash, BRTransactionEq, txCount + 100);
BRWallet.c:    wallet->invalidTx = BRSetNew(BRTransactionHash, BRTransactionEq, 10);
BRWallet.c:    wallet->pendingTx = BRSetNew(BRTransactionHash, BRTransactionEq, 10);
BRWallet.c:    wallet->spentOutputs = BRSetNew(BRUTXOHash, BRUTXOEq, txCount + 100);
BRWallet.c:    wallet->usedAddrs = BRSetNew(BRAddressHash, BRAddressEq, txCount + 100);
BRWallet.c:    wallet->allAddrs = BRSetNew(BRAddressHash, BRAddressEq, txCount + 100);
BRWallet.c:    pthread_mutex_init(&wallet->lock, NULL);
BRWallet.c:    wallet->params = params;
BRWallet.c:        if (! BRTransactionIsSigned(tx) || BRSetContains(wallet->allTx, tx)) continue;
BRWallet.c:        BRSetAdd(wallet->allTx, tx);
BRWallet.c:            if (tx->outputs[j].address[0] != '\0') BRSetAdd(wallet->usedAddrs, tx->outputs[j].address);
BRWallet.c:    wallet->callbackInfo = info;
BRWallet.c:    wallet->balanceChanged = balanceChanged;
BRWallet.c:    wallet->txAdded = txAdded;
BRWallet.c:    wallet->txUpdated = txUpdated;
BRWallet.c:    wallet->txDeleted = txDeleted;
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    addrChain = (internal) ? wallet->internalChain : wallet->externalChain;
BRWallet.c:    while (i > 0 && ! BRSetContains(wallet->usedAddrs, &addrChain[i - 1])) i--;
BRWallet.c:        uint8_t pubKey[BRBIP32PubKey(NULL, 0, wallet->masterPubKey, chain, count)];
BRWallet.c:        size_t len = BRBIP32PubKey(pubKey, sizeof(pubKey), wallet->masterPubKey, chain, (uint32_t)count);
BRWallet.c:        if (! BRKeyAddress(&key, wallet->params, address.s, sizeof(address)) || BRAddressEq(&address, &BR_ADDRESS_NONE)) break;
BRWallet.c:        if (BRSetContains(wallet->usedAddrs, &address)) i = count;
BRWallet.c:    if (addrChain == (internal ? wallet->internalChain : wallet->externalChain)) {
BRWallet.c:            BRSetAdd(wallet->allAddrs, &addrChain[i]);
BRWallet.c:        if (internal) wallet->internalChain = addrChain;
BRWallet.c:        if (! internal) wallet->externalChain = addrChain;
BRWallet.c:        BRSetClear(wallet->allAddrs); // clear and rebuild allAddrs
BRWallet.c:        for (i = array_count(wallet->internalChain); i > 0; i--) {
BRWallet.c:            BRSetAdd(wallet->allAddrs, &wallet->internalChain[i - 1]);
BRWallet.c:        for (i = array_count(wallet->externalChain); i > 0; i--) {
BRWallet.c:            BRSetAdd(wallet->allAddrs, &wallet->externalChain[i - 1]);
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    balance = wallet->balance;
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    if (! utxos || array_count(wallet->utxos) < utxosCount) utxosCount = array_count(wallet->utxos);
BRWallet.c:        utxos[i] = wallet->utxos[i];
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    if (! transactions || array_count(wallet->transactions) < txCount) txCount = array_count(wallet->transactions);
BRWallet.c:        transactions[i] = wallet->transactions[i];
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    total = array_count(wallet->transactions);
BRWallet.c:    while (n < total && wallet->transactions[(total - n) - 1]->blockHeight >= blockHeight) n++;
BRWallet.c:        transactions[i] = wallet->transactions[(total - n) + i];
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    totalSent = wallet->totalSent;
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    totalReceived = wallet->totalReceived;
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    feePerKb = wallet->feePerKb;
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    wallet->feePerKb = feePerKb;
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    internalCount = (! addrs || array_count(wallet->internalChain) < addrsCount) ?
BRWallet.c:                    array_count(wallet->internalChain) : addrsCount;
BRWallet.c:        addrs[i] = wallet->internalChain[i];
BRWallet.c:    externalCount = (! addrs || array_count(wallet->externalChain) < addrsCount - internalCount) ?
BRWallet.c:                    array_count(wallet->externalChain) : addrsCount - internalCount;
BRWallet.c:        addrs[internalCount + i] = wallet->externalChain[i];
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    if (addr) r = BRSetContains(wallet->allAddrs, addr);
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    if (addr) r = BRSetContains(wallet->usedAddrs, addr);
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:            wallet->params,
BRWallet.c:    BRTxOutputSetAddress(wallet->params,
BRWallet.c:    BRTransaction *tx, *transaction = BRTransactionNew(wallet->params);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    feeAmount = _txFee(wallet->feePerKb, BRTransactionSize(transaction) + TX_OUTPUT_SIZE);
BRWallet.c:    for (i = 0; i < array_count(wallet->utxos); i++) {
BRWallet.c:        o = &wallet->utxos[i];
BRWallet.c:        tx = BRSetGet(wallet->allTx, o);
BRWallet.c:            if (wallet->balance < amount + _txFee(wallet->feePerKb, 10 + array_count(wallet->utxos)*TX_INPUT_SIZE +
BRWallet.c:            pthread_mutex_unlock(&wallet->lock);
BRWallet.c:            pthread_mutex_lock(&wallet->lock);
BRWallet.c:        feeAmount = _txFee(wallet->feePerKb, BRTransactionSize(transaction) + TX_OUTPUT_SIZE + cpfpSize);
BRWallet.c:        if (wallet->balance > amount + feeAmount) feeAmount += (wallet->balance - (amount + feeAmount)) % 100;
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:                wallet->params,
BRWallet.c:                wallet->params,
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:        for (j = (uint32_t)array_count(wallet->internalChain); j > 0; j--) {
BRWallet.c:            if (BRAddressEq(tx->inputs[i].address, &wallet->internalChain[j - 1])) internalIdx[internalCount++] = j - 1;
BRWallet.c:        for (j = (uint32_t)array_count(wallet->externalChain); j > 0; j--) {
BRWallet.c:            if (BRAddressEq(tx->inputs[i].address, &wallet->externalChain[j - 1])) externalIdx[externalCount++] = j - 1;
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:        pthread_mutex_lock(&wallet->lock);
BRWallet.c:        if (! BRSetContains(wallet->allTx, tx)) {
BRWallet.c:                BRSetAdd(wallet->allTx, tx);
BRWallet.c:                if (tx->blockHeight == TX_UNCONFIRMED) BRSetAdd(wallet->allTx, tx);
BRWallet.c:                // BUG: XXX memory leak if tx is not added to wallet->allTx, and we can't just free it
BRWallet.c:        pthread_mutex_unlock(&wallet->lock);
BRWallet.c:        if (wallet->balanceChanged) wallet->balanceChanged(wallet->callbackInfo, wallet->balance);
BRWallet.c:        if (wallet->txAdded) wallet->txAdded(wallet->callbackInfo, tx);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    tx = BRSetGet(wallet->allTx, &txHash);
BRWallet.c:        for (size_t i = array_count(wallet->transactions); i > 0; i--) { // find depedent transactions
BRWallet.c:            t = wallet->transactions[i - 1];
BRWallet.c:            pthread_mutex_unlock(&wallet->lock);
BRWallet.c:            for (size_t i = array_count(wallet->transactions); i > 0; i--) {
BRWallet.c:                if (! BRTransactionEq(wallet->transactions[i - 1], tx)) continue;
BRWallet.c:                array_rm(wallet->transactions, i - 1);
BRWallet.c:            pthread_mutex_unlock(&wallet->lock);
BRWallet.c:            if (wallet->balanceChanged) wallet->balanceChanged(wallet->callbackInfo, wallet->balance);
BRWallet.c:            if (wallet->txDeleted) wallet->txDeleted(wallet->callbackInfo, txHash, notifyUser, recommendRescan);
BRWallet.c:    else pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    tx = BRSetGet(wallet->allTx, &txHash);
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:        pthread_mutex_lock(&wallet->lock);
BRWallet.c:        if (! BRSetContains(wallet->allTx, tx)) {
BRWallet.c:                if (BRSetContains(wallet->spentOutputs, &tx->inputs[i])) r = 0;
BRWallet.c:        else if (BRSetContains(wallet->invalidTx, tx)) r = 0;
BRWallet.c:        pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    blockHeight = wallet->blockHeight;
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    if (blockHeight > wallet->blockHeight) wallet->blockHeight = blockHeight;
BRWallet.c:        tx = BRSetGet(wallet->allTx, &txHashes[i]);
BRWallet.c:            for (k = array_count(wallet->transactions); k > 0; k--) { // remove and re-insert tx to keep wallet sorted
BRWallet.c:                if (! BRTransactionEq(wallet->transactions[k - 1], tx)) continue;
BRWallet.c:                array_rm(wallet->transactions, k - 1);
BRWallet.c:            if (BRSetContains(wallet->pendingTx, tx) || BRSetContains(wallet->invalidTx, tx)) needsUpdate = 1;
BRWallet.c:            BRSetRemove(wallet->allTx, tx);
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    if (j > 0 && wallet->txUpdated) wallet->txUpdated(wallet->callbackInfo, hashes, j, blockHeight, timestamp);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    wallet->blockHeight = blockHeight;
BRWallet.c:    count = i = array_count(wallet->transactions);
BRWallet.c:    while (i > 0 && wallet->transactions[i - 1]->blockHeight > blockHeight) i--;
BRWallet.c:        wallet->transactions[i + j]->blockHeight = TX_UNCONFIRMED;
BRWallet.c:        hashes[j] = wallet->transactions[i + j]->txHash;
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    if (count > 0 && wallet->txUpdated) wallet->txUpdated(wallet->callbackInfo, hashes, count, TX_UNCONFIRMED, 0);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:        if (BRSetContains(wallet->allAddrs, tx->outputs[i].address)) amount += tx->outputs[i].amount;
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:        BRTransaction *t = BRSetGet(wallet->allTx, &tx->inputs[i].txHash);
BRWallet.c:        if (t && n < t->outCount && BRSetContains(wallet->allAddrs, t->outputs[n].address)) {
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:        BRTransaction *t = BRSetGet(wallet->allTx, &tx->inputs[i].txHash);
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    balance = wallet->balance;
BRWallet.c:    for (size_t i = array_count(wallet->transactions); tx && i > 0; i--) {
BRWallet.c:        if (! BRTransactionEq(tx, wallet->transactions[i - 1])) continue;
BRWallet.c:        balance = wallet->balanceHist[i - 1];
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    fee = _txFee(wallet->feePerKb, size);
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:            wallet->params,
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    amount = (TX_MIN_OUTPUT_AMOUNT*wallet->feePerKb + MIN_FEE_PER_KB - 1)/MIN_FEE_PER_KB;
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    for (i = array_count(wallet->utxos); i > 0; i--) {
BRWallet.c:        o = &wallet->utxos[i - 1];
BRWallet.c:        tx = BRSetGet(wallet->allTx, &o->hash);
BRWallet.c:    fee = _txFee(wallet->feePerKb, txSize + cpfpSize);
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    return wallet->params->forkId;
BRWallet.c:    return wallet->params->algoId;
BRWallet.c:    return wallet->params->protocolVersion;
BRWallet.c:    return wallet->params->minProtoVersion;
BRWallet.c:    pthread_mutex_lock(&wallet->lock);
BRWallet.c:    BRSetFree(wallet->allAddrs);
BRWallet.c:    BRSetFree(wallet->usedAddrs);
BRWallet.c:    BRSetFree(wallet->invalidTx);
BRWallet.c:    BRSetFree(wallet->pendingTx);
BRWallet.c:    BRSetApply(wallet->allTx, NULL, _setApplyFreeTx);
BRWallet.c:    BRSetFree(wallet->allTx);
BRWallet.c:    BRSetFree(wallet->spentOutputs);
BRWallet.c:    array_free(wallet->internalChain);
BRWallet.c:    array_free(wallet->externalChain);
BRWallet.c:    array_free(wallet->balanceHist);
BRWallet.c:    array_free(wallet->transactions);
BRWallet.c:    array_free(wallet->utxos);
BRWallet.c:    pthread_mutex_unlock(&wallet->lock);
BRWallet.c:    pthread_mutex_destroy(&wallet->lock);
Java/Makefile:#     javah -jni -d ${APP}/app/src/main/cpp/breadwallet-core/Java/ \
Java/Notes:            src/main/cpp/breadwallet-core/BRAddress.c
Java/Notes:            src/main/cpp/breadwallet-core/BRAddress.h
Java/Notes:            src/main/cpp/breadwallet-core/BRArray.h
Java/Notes:            src/main/cpp/breadwallet-core/BRBase58.c
Java/Notes:            src/main/cpp/breadwallet-core/BRBase58.h
Java/Notes:            src/main/cpp/breadwallet-core/BRBIP32Sequence.c
Java/Notes:            src/main/cpp/breadwallet-core/BRBIP32Sequence.h
Java/Notes:            src/main/cpp/breadwallet-core/BRBIP38Key.c
Java/Notes:            src/main/cpp/breadwallet-core/BRBIP38Key.h
Java/Notes:            src/main/cpp/breadwallet-core/BRBIP39Mnemonic.c
Java/Notes:            src/main/cpp/breadwallet-core/BRBIP39Mnemonic.h
Java/Notes:            src/main/cpp/breadwallet-core/BRBIP39WordsEn.h
Java/Notes:            src/main/cpp/breadwallet-core/BRBloomFilter.c
Java/Notes:            src/main/cpp/breadwallet-core/BRBloomFilter.h
Java/Notes:            src/main/cpp/breadwallet-core/BRCrypto.c
Java/Notes:            src/main/cpp/breadwallet-core/BRCrypto.h
Java/Notes:            src/main/cpp/breadwallet-core/BRInt.h
Java/Notes:            src/main/cpp/breadwallet-core/BRKey.c
Java/Notes:            src/main/cpp/breadwallet-core/BRKey.h
Java/Notes:            src/main/cpp/breadwallet-core/BRMerkleBlock.c
Java/Notes:            src/main/cpp/breadwallet-core/BRMerkleBlock.h
Java/Notes:            src/main/cpp/breadwallet-core/BRPaymentProtocol.c
Java/Notes:            src/main/cpp/breadwallet-core/BRPaymentProtocol.h
Java/Notes:            src/main/cpp/breadwallet-core/BRPeer.c
Java/Notes:            src/main/cpp/breadwallet-core/BRPeer.h
Java/Notes:            src/main/cpp/breadwallet-core/BRPeerManager.c
Java/Notes:            src/main/cpp/breadwallet-core/BRPeerManager.h
Java/Notes:            src/main/cpp/breadwallet-core/BRSet.c
Java/Notes:            src/main/cpp/breadwallet-core/BRSet.h
Java/Notes:            src/main/cpp/breadwallet-core/BRTransaction.c
Java/Notes:            src/main/cpp/breadwallet-core/BRTransaction.h
Java/Notes:            src/main/cpp/breadwallet-core/BRWallet.c
Java/Notes:            src/main/cpp/breadwallet-core/BRWallet.h
Java/Notes:                           src/main/cpp/breadwallet-core/Java/BRCoreJni.h
Java/Notes:                           src/main/cpp/breadwallet-core/Java/BRCoreJni.c
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreJniReference.c
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreJniReference.h
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreAddress.c
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreAddress.h
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreChainParams.c
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreChainParams.h
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCorePeer.c
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCorePeer.h
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreMasterPubKey.c
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreMasterPubKey.h
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreKey.h
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreKey.c
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreMerkleBlock.c
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreMerkleBlock.h
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCorePeerManager.c
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCorePeerManager.h
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreTransaction.c
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreTransaction.h
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreTransactionInput.c
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreTransactionInput.h
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreTransactionOutput.c
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreTransactionOutput.h
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCorePaymentProtocol.c
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCorePaymentProtocol.h
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreWallet.c
Java/Notes:                           src/main/cpp/breadwallet-core/Java/com_breadwallet_core_BRCoreWallet.h
Java/Notes:include_directories(src/main/cpp/breadwallet-core/Java)
Java/Notes:include_directories(src/main/cpp/breadwallet-core/)
Java/Notes:include_directories(src/main/cpp/breadwallet-core/secp256k1/include)
Java/Notes:include_directories(src/main/cpp/breadwallet-core/secp256k1/src)
Java/Notes:include_directories(src/main/cpp/breadwallet-core/secp256k1)
Java/Notes:JNI_DIR=${PROJECT_DIR}/src/main/cpp/breadwallet-core/Java/
Java/com_breadwallet_core_BRCoreWallet.c:    //   We should not copy; but we need to deal with wallet-initiated 'free'
README.md:# breadwallet-core
README.md:[getting started](https://github.com/breadwallet/breadwallet-core/wiki)
bcash/BRBCashAddr.c://  breadwallet-core
bcash/BRBCashAddr.h://  breadwallet-core
